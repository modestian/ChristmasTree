<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¥ä½ åœ£è¯å¿«ä¹ - ç’€ç’¨å®šæ ¼ç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #020205;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Microsoft YaHei', sans-serif;
        }

        #canvas {
            display: block;
            cursor: pointer;
        }
        
        .tip {
            position: absolute;
            bottom: 20px;
            color: rgba(255, 255, 255, 0.6);
            pointer-events: none;
            user-select: none;
            font-size: 14px;
            text-shadow: 0 0 2px rgba(255,255,255,0.5);
            animation: breathe 2s infinite ease-in-out;
            text-align: center;
            line-height: 1.5;
            z-index: 10;
        }

        @keyframes breathe {
            0%, 100% { opacity: 0.4; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
        }
    </style>
</head>
<body>

    <canvas id="canvas"></canvas>
    <div class="tip">ç‚¹å‡»å±å¹•å‘å°„çƒŸèŠ±<br> ä½œè€…ï¼šmodestianğŸ°â¤ï¸ğŸ</div>

    <script>
        // ===========================
        // 1. æ ‘ç²’å­ç±» (ä¿æŒä¸å˜)
        // ===========================
        class TreeParticle {
            constructor(x, y, canvas, type = 'leaf') {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.originalX = x;
                this.originalY = y;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.targetX = x;
                this.targetY = y;
                this.speed = Math.random() * 0.4 + 0.1; 
                this.radius = Math.random() * 2.5 + 1; 
                this.type = type;
                this.hue = this.initHue(type);
                this.opacity = Math.random() * 0.5 + 0.5;
                this.floatAngle = Math.random() * Math.PI * 2; 
            }

            initHue(type) {
                if (type === 'trunk') return 30;
                if (type === 'star') return 50;
                return Math.random() > 0.8 ? Math.random() * 360 : (90 + Math.random() * 60); 
            }

            update() {
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                this.vx += dx * this.speed * 0.01;
                this.vy += dy * this.speed * 0.01;
                this.floatAngle += 0.02;
                this.vx += Math.cos(this.floatAngle) * 0.02;
                this.vy += Math.sin(this.floatAngle) * 0.02;
                this.vx *= 0.92;
                this.vy *= 0.92;
                this.x += this.vx;
                this.y += this.vy;
                if(this.type !== 'trunk') this.hue += 0.5;
            }

            draw() {
                this.ctx.beginPath();
                this.ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = `hsla(${this.hue}, 80%, 60%, ${this.opacity})`;
                this.ctx.fill();
            }

            setTarget(x, y) { this.targetX = x; this.targetY = y; }
            reset() { this.setTarget(this.originalX, this.originalY); }
            
            goToGalaxyPosition() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const angle = Math.random() * Math.PI * 2 * 4; 
                const distance = Math.random() * (Math.min(this.canvas.width, this.canvas.height) / 1.8);
                this.setTarget(centerX + Math.cos(angle) * distance, centerY + Math.sin(angle) * distance);
            }
        }

        // ===========================
        // 2. çƒŸèŠ±å¼¹ç±»
        // ===========================
        class Rocket {
            constructor(startX, targetY, shapeType, ctx) {
                this.x = startX;
                this.y = ctx.canvas.height;
                this.targetY = targetY;
                this.shapeType = shapeType;
                this.ctx = ctx;
                this.vy = -(Math.random() * 3 + 12); 
                this.vx = (Math.random() - 0.5) * 2;
                this.gravity = 0.2;
                this.trail = []; 
                this.exploded = false;
                this.hue = Math.random() * 360;
            }

            update() {
                this.trail.push({x: this.x, y: this.y});
                if (this.trail.length > 5) this.trail.shift();

                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.vx *= 0.99;

                if (this.vy >= -1 || this.y <= this.targetY) {
                    this.exploded = true;
                }
            }

            draw() {
                for(let i = 0; i < this.trail.length; i++) {
                    const p = this.trail[i];
                    const progress = (i + 1) / this.trail.length;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, 2 * progress, 0, Math.PI * 2);
                    this.ctx.fillStyle = `hsla(${this.hue}, 100%, 70%, ${progress * 0.5})`;
                    this.ctx.fill();
                }
                this.ctx.beginPath();
                this.ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                this.ctx.fillStyle = `hsl(${this.hue}, 100%, 80%)`;
                this.ctx.fill();
            }
        }

        // ===========================
        // 3. çˆ†ç‚¸ç²’å­ç±» (æ ¸å¿ƒç‰©ç†è°ƒæ•´)
        // ===========================
        class Spark {
            constructor(x, y, vx, vy, hue, ctx) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.hue = hue;
                this.ctx = ctx;
                
                // ã€è°ƒæ•´1ã€‘æä½é‡åŠ›ï¼šè®©å½¢çŠ¶åƒæ‚¬æµ®åœ¨ç©ºä¸­ä¸€æ ·
                this.gravity = 0.025; 
                
                // ã€è°ƒæ•´2ã€‘é«˜ç©ºæ°”é˜»åŠ›ï¼šè®©ç²’å­ç‚¸å¼€åè¿…é€Ÿåˆ¹è½¦ï¼Œä¿æŒé˜Ÿå½¢
                this.friction = 0.92; 
                
                this.alpha = 1;
                // ã€è°ƒæ•´3ã€‘è¶…é•¿å¯¿å‘½ï¼šå‡ç¼“æ¶ˆå¤±é€Ÿåº¦
                this.decay = Math.random() * 0.005 + 0.005; 
                
                this.size = Math.random() * 2 + 1;
            }

            update() {
                this.vx *= this.friction;
                this.vy *= this.friction;
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                this.alpha -= this.decay;
                this.hue += 0.2; // é¢œè‰²å˜åŒ–æ…¢ä¸€ç‚¹
            }

            draw() {
                this.ctx.save();
                this.ctx.globalAlpha = this.alpha;
                this.ctx.fillStyle = `hsl(${this.hue}, 100%, 65%)`;
                this.ctx.beginPath();
                this.ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
            }
        }

        // ===========================
        // 4. æ‰è½æ–‡å­—ç±»
        // ===========================
        class FallingText {
            constructor(text, x, y, ctx) {
                this.text = text;
                this.x = x;
                this.y = y;
                this.ctx = ctx;
                this.speed = Math.random() * 1.5 + 1; 
                this.fontSize = Math.random() * 10 + 20; 
                this.hue = Math.random() * 360;
                this.oscillation = 0;
            }

            update() {
                this.y += this.speed;
                this.oscillation += 0.05;
                this.x += Math.sin(this.oscillation) * 0.5; 
                this.hue += 1;
            }

            draw() {
                this.ctx.save();
                this.ctx.font = `bold ${this.fontSize}px "Microsoft YaHei"`;
                this.ctx.fillStyle = `hsl(${this.hue}, 100%, 75%)`;
                this.ctx.fillText(this.text, this.x, this.y);
                this.ctx.restore();
            }
        }

        // ===========================
        // 5. ä¸»æ§ç±»
        // ===========================
        class ChristmasTree {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.treeParticles = [];     
                this.rockets = [];
                this.sparks = [];
                this.fallingTexts = [];      
                
                this.isGalaxy = false;
                this.lastClickTime = 0;
                
                this.init();
            }

            init() {
                this.resizeCanvas();
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                    this.createTreeParticles(); 
                });
                
                this.canvas.addEventListener('click', (e) => this.handleInteraction(e));
                this.createTreeParticles();
                this.animate();
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            createTreeParticles() {
                this.treeParticles = [];
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2 - 40;
                
                // æ ‘å¹²
                for (let i = 0; i < 80; i++) { 
                    const x = centerX + (Math.random() - 0.5) * 30;
                    const y = centerY + 350 + Math.random() * 40;
                    this.treeParticles.push(new TreeParticle(x, y, this.canvas, 'trunk'));
                }
                
                // æ ‘å† 
                const levels = 15; 
                for (let level = 0; level < levels; level++) {
                    const progress = level / levels; 
                    const currentY = centerY + progress * 350;
                    const currentWidth = 280 * progress; 
                    const particlesInLevel = 35 + level * 20; 
                    
                    for(let i=0; i<particlesInLevel; i++) {
                        const x = centerX + (Math.random() - 0.5) * currentWidth;
                        const y = currentY + Math.random() * 15;
                        this.treeParticles.push(new TreeParticle(x, y, this.canvas, 'leaf'));
                    }
                }
                
                // æ ‘é¡¶æ˜Ÿ
                for(let i=0; i<30; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.random() * 15;
                    this.treeParticles.push(new TreeParticle(
                        centerX + Math.cos(angle) * r, 
                        centerY - 10 + Math.sin(angle) * r, 
                        this.canvas, 'star'
                    ));
                }
            }

            handleInteraction(e) {
                const now = Date.now();
                if (now - this.lastClickTime < 100) return;
                this.lastClickTime = now;

                this.isGalaxy = !this.isGalaxy;
                this.isGalaxy ? 
                    this.treeParticles.forEach(p => p.goToGalaxyPosition()) : 
                    this.treeParticles.forEach(p => p.reset());

                this.launchRocket();
                this.dropTexts();
            }

            launchRocket() {
                const shapes = ['rabbit', 'heart', 'gift'];
                const count = 1 + Math.floor(Math.random() * 2);
                
                for(let i=0; i<count; i++) {
                    const startX = Math.random() * this.canvas.width * 0.8 + this.canvas.width * 0.1;
                    const targetY = Math.random() * (this.canvas.height * 0.4) + 50;
                    const shape = shapes[Math.floor(Math.random() * shapes.length)];
                    
                    setTimeout(() => {
                        this.rockets.push(new Rocket(startX, targetY, shape, this.ctx));
                    }, i * 150);
                }
            }

            explodeRocket(rocket) {
                const centerX = rocket.x;
                const centerY = rocket.y;
                const type = rocket.shapeType;
                
                // ã€è°ƒæ•´4ã€‘é«˜çˆ†å‘åŠ›ï¼šé…åˆé«˜é˜»åŠ›ï¼Œå®ç°ç¬é—´ç‚¸å¼€ç„¶ååœé¡¿çš„æ•ˆæœ
                const power = 8; 

                let baseHue;
                if (type === 'heart') baseHue = 340;
                else if (type === 'rabbit') baseHue = 300;
                else if (type === 'gift') baseHue = 45;

                const getHue = () => baseHue + (Math.random() - 0.5) * 40;

                // --- 1. çˆ±å¿ƒ ---
                if (type === 'heart') {
                    // ç²’å­æ•°é‡å¢åŠ åˆ° 120ï¼Œæç»˜å‡ºå®çº¿è½®å»“
                    for(let i=0; i<120; i++) {
                        const t = (Math.PI * 2 * i) / 120;
                        const dirX = 16 * Math.pow(Math.sin(t), 3);
                        const dirY = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                        // å‡å°‘éšæœºæ€§ï¼Œè®©è½®å»“æ›´æ¸…æ™°
                        const scale = (0.08 * Math.random() + 0.12); 
                        this.sparks.push(new Spark(centerX, centerY, dirX * scale * power * 0.5, dirY * scale * power * 0.5, getHue(), this.ctx));
                    }
                }
                
                // --- 2. å…”å­ ---
                else if (type === 'rabbit') {
                    // å¤´ (å¢åŠ ç²’å­å¯†åº¦)
                    for(let i=0; i<80; i++) {
                        const angle = (Math.PI * 2 * i) / 80;
                        const v = 2.5; // å›ºå®šé€Ÿåº¦ï¼Œå½¢æˆåœ†ç¯è€Œéå®å¿ƒ
                        this.sparks.push(new Spark(centerX, centerY, Math.cos(angle)*v*power*0.5, Math.sin(angle)*v*power*0.5, getHue(), this.ctx));
                    }
                    // è€³æœµ
                    const createEar = (offsetX, rot) => {
                        for(let i=0; i<50; i++) {
                            const t = (Math.PI * 2 * i) / 50;
                            const ex = Math.cos(t) * 0.8; 
                            const ey = Math.sin(t) * 2.5; 
                            const fx = ex * Math.cos(rot) - ey * Math.sin(rot) + offsetX;
                            const fy = ex * Math.sin(rot) + ey * Math.cos(rot) - 2; 
                            this.sparks.push(new Spark(centerX, centerY, fx * power * 0.5, fy * power * 0.5, getHue(), this.ctx));
                        }
                    };
                    createEar(-1.5, -0.3);
                    createEar(1.5, 0.3);
                }
                
                // --- 3. ç¤¼ç‰© ---
                else if (type === 'gift') {
                    // ç»˜åˆ¶æ­£æ–¹å½¢è½®å»“ï¼Œè€Œä¸æ˜¯éšæœºç‚¸å¼€
                    const size = 6; 
                    const particlesPerSide = 25;
                    
                    // å®šä¹‰æ­£æ–¹å½¢è¾¹æ¡†å‡½æ•°
                    const addLine = (x1, y1, x2, y2) => {
                        for(let i=0; i<particlesPerSide; i++) {
                            const p = i / particlesPerSide;
                            const dx = x1 + (x2 - x1) * p;
                            const dy = y1 + (y2 - y1) * p;
                            // ç¨å¾®åŠ ä¸€ç‚¹ç‚¹éšæœºæŠ–åŠ¨ï¼Œæ˜¾å¾—è‡ªç„¶
                            const jitterX = (Math.random()-0.5) * 0.5;
                            const jitterY = (Math.random()-0.5) * 0.5;
                            this.sparks.push(new Spark(centerX, centerY, (dx+jitterX) * power * 0.3, (dy+jitterY) * power * 0.3, 0, this.ctx)); // çº¢è‰²ç›’å­
                        }
                    }

                    // å››æ¡è¾¹
                    addLine(-size, -size, size, -size);
                    addLine(size, -size, size, size);
                    addLine(size, size, -size, size);
                    addLine(-size, size, -size, -size);
                    
                    // é‡‘è‰²ä¸å¸¦ï¼ˆåå­—ï¼‰
                    for(let i=0; i<particlesPerSide*2; i++) {
                         // æ¨ªå‘ä¸å¸¦
                         if(i % 2 === 0) {
                             const p = i / (particlesPerSide*2);
                             const dx = -size + size * 2 * p;
                             this.sparks.push(new Spark(centerX, centerY, dx * power * 0.3, 0, 50, this.ctx));
                         } else {
                             // çºµå‘ä¸å¸¦
                             const p = i / (particlesPerSide*2);
                             const dy = -size + size * 2 * p;
                             this.sparks.push(new Spark(centerX, centerY, 0, dy * power * 0.3, 50, this.ctx));
                         }
                    }
                }
            }

            dropTexts() {
                const phrases = ["ç¥ä½ åœ£è¯å¿«ä¹", "å¹³å®‰å–œä¹", "ä¸‡äº‹èƒœæ„", "Merry Christmas", "ğŸ°â¤ï¸", "âœ¨ğŸ"];
                const count = 5 + Math.floor(Math.random() * 2); 
                for (let i = 0; i < count; i++) {
                    const text = phrases[Math.floor(Math.random() * phrases.length)];
                    const x = Math.random() * this.canvas.width;
                    const y = -50 - Math.random() * 100; 
                    this.fallingTexts.push(new FallingText(text, x, y, this.ctx));
                }
            }

            animate() {
                this.ctx.globalCompositeOperation = 'source-over';
                this.ctx.fillStyle = 'rgba(2, 2, 5, 0.2)'; 
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.globalCompositeOperation = 'lighter';

                this.treeParticles.forEach(p => { p.update(); p.draw(); });

                for (let i = this.rockets.length - 1; i >= 0; i--) {
                    const r = this.rockets[i];
                    r.update();
                    r.draw();
                    if (r.exploded) {
                        this.explodeRocket(r);
                        this.rockets.splice(i, 1);
                    }
                }

                for (let i = this.sparks.length - 1; i >= 0; i--) {
                    const s = this.sparks[i];
                    s.update();
                    s.draw();
                    if (s.alpha <= 0) {
                        this.sparks.splice(i, 1);
                    }
                }

                this.ctx.globalCompositeOperation = 'source-over';
                for (let i = this.fallingTexts.length - 1; i >= 0; i--) {
                    const t = this.fallingTexts[i];
                    t.update();
                    t.draw();
                    if (t.y > this.canvas.height + 50) {
                        this.fallingTexts.splice(i, 1);
                    }
                }
                
                requestAnimationFrame(() => this.animate());
            }
        }

        window.addEventListener('load', () => {
            new ChristmasTree();
        });
    </script>
</body>
</html>